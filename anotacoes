ANOTACOES GERAIS:

**Sempre PULL**

	--git config (--global) user.name "Tatá incrível"
	--git config (--global) user.mail "tataomaisincrivel@yahoo.com"
	--git clone ...
	--git branch feature-implementacaoSHop
	--git remote add feature-implementacaoShop "urlmaingit"
	--git push -u origin new-branch
	--git pull
	Problemas Linux/Ubuntu
	--Pode ocorrer a necessidade de uma key para a sua conta do git, me chama.
	
COMO IR PARA OUTRO COMMIT:
	checkout.
	git checkout 'idCommit'	
	podemos usar para branch tbm.
	
STASH:
	git stash save "mensagem"
	git stash list
	git stash pop
	
**Precisa deixar explícito para o git o que subir, de preferencia nao subir arquivos com informacoes confidenciais.**

COMO?
	git ignore: untracked(ngm ta monitorando)/tracked(monitorando)/ignored(aquivos a toa, PDF(??))
	
	tracked | untracked | ignored
	
	touch .gitignore && echo nomes dos arquiso >> .gitignore
	Padrao de globbing
	/ FORMA FACIL DE COLOCAR ARQUIVOS NAO NECESSARIOS:
		*.log /
		
MERGE:
	-Quanto menor a arvore, melhor o projeto.
	-Sempre onde recebe.
	+Conflitos: Normal, cabe o desenvolvedor saber o que é melhor. Apaga na mao e da commit instantaneamente comuniacando geral.
	Uma possivel solucao, é Integracao conitnua
		'EXTREME PROGRAMMING (XP) --FACEBOOK--'
		https://www.alura.com.br/artigos/assets/git-hub/modelo-distribuido.png

		trunk-based com commits pequenos direto na main e se der merda rollback.
	--git merge :Junta tudo ai, 
	
		git checkout ATUALbranch
		git merge new-branch
		
		pode dar conflito!:
			
			Cabe ao desenvolvendor escolher a melhor forma de prosseguir.
	--PRs
		Após fazer oq precisa, jogar pra develop e testar. Estando tudo certo pede PR pra main.
		--Vai pro gitHub e pede integração com a branch em produçao. Os colaboradores têm permissão para liberar.
		
		https://www.alura.com.br/artigos/assets/git-hub/pull-request.png

	Apos o PR, deletar o branch remoto é bom:
		git push origin --delete /nome-branch
	  	git branch -d new-branch
	
	
	--rebase -> muda o passado.
		Tem que preferir o rebase ao inves do merge, isso vai de projeto para projeto. O mais comum é fazer em projetos curtos e com trabalho solo.
					
	
Grafo de commmits:
	Uma estrtura de dados :TAD: que representa um commit (grafos) na sequencia (branch) apontando para o commit a seguir.

	https://www.hostinger.com.br/tutoriais/wp-content/uploads/sites/12/2017/05/git-tutorials-03-br.webp

	O ideal para o nosso caso é:
		**MAIN | <DEVELOP> <HOTFIX> | DEVs** 
		-Separar cada linha do tempo:
			Para os nomes de branch o ideal é: 'FEAT-tataManeiro'.
		-Cada um com seu user global, com acesso de colaborador.
		-Clean Code, ou pelo menos algo parecido com isso 
			possível reunião sobre C.C? comentários,documentação,nomes...
		-Conventional commits.
			Exste um padrão para mensagens de commits:
			-Nomes: 
				TEST: alteração ou criação de codigo de testes.
				Revert: reversão de um commit anterior.
				PERFormance: melhoras na perfomance do programa.
				Build: alterar processo de build; não vamos usar.
				DOCS: mudanã na documentação.
				FIX: correção de erros.
				FEATure: indica o desenvolvimento de uma funcao nova, servico, endpoint...
				Refactor: ordem dos fatores nao altera o produto. 
				Style: mudar identação...
				chore: mudanças no desenvolvimento. GITIGNORE 
			https://miro.medium.com/v2/resize:fit:720/format:webp/1*IZPTYtwxI-UgULgOjf8GKQ.png
			
		-Teste canário||possivel solucao para testarmos a shopify.
		
		

